# agent_state.py #

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any


class AgentState(BaseModel):
    input_contract:str
    errors: List[str] = Field(default_factory=list)
    message: Optional[str] = None
    feedback: Optional[str] = None
    summary: Optional[str] = None
    risk_analysis_report: Optional[Dict[str, Any]] = None
    status: Optional[str] = None # "failed" | "in_progress" | "success"



# orchestrator_agent.py #
from langgraph.graph import StateGraph, START, END
from .agent_state import AgentState
from .validation_agent import ValidationAgent
from .risk_analysis_agent import RiskAnalysisAgent
from .summarizer_agent import SummarizerAgent


class OrchestratorAgent:
    def __init__(self, state: AgentState):
        self.state = state
        self.validation = ValidationAgent()
        self.analyzer = RiskAnalysisAgent()
        self.summarizer = SummarizerAgent()

        self.graph = self._build_graph()

    @staticmethod
    def route_after_validation(state: AgentState):
        if state.errors or state.status == "failed":
            return "end"
        return "analyzer"

    @staticmethod
    def route_after_analyzer(state: AgentState):
        if state.errors or state.status == "failed" or not state.risk_analysis_report:
            return "end"
        return "summarizer"


    def _build_graph(self):
        g = StateGraph(AgentState)
        g.add_node("validation", self.validation)
        g.add_node("analyzer", self.analyzer)
        g.add_node("summarizer", self.summarizer)

        g.add_edge(START, "validation")
        g.add_conditional_edges(
            "validation",
            OrchestratorAgent.route_after_validation,
            {"analyzer": "analyzer", "end": END}
        )
        g.add_conditional_edges(
            "analyzer",
            OrchestratorAgent.route_after_analyzer,
            {"summarizer": "summarizer", "end": END}
        )

        g.add_edge("summarizer", END)

        g.set_entry_point("validation")

        return g.compile()

    def run(self) -> AgentState:
        result = self.graph.invoke(self.state)
        if isinstance(result, dict):
            return AgentState(**result)
        return result



## risk_analysis_agent.py ##
from .agent_state import AgentState
from prompts.risk_analysis_prompt import risk_analysis_prompt
from llm.gemini_service import call_gemini_llm
from utils.common import extract_json


class RiskAnalysisAgent:
    def __call__(self, state: AgentState):
        self.state = state
        self.user_input = state.input_contract
        return self.run_analyzer()

    def run_analyzer(self) -> AgentState:
        if self.state.feedback:
            self.state.input_contract += f"\nAdditional Context: {self.state.feedback}"

        prompt = risk_analysis_prompt + self.state.input_contract
        resp_text = call_gemini_llm(prompt)
        resp_json = extract_json(resp_text) or {}
        print(f"RiskAnalysisAgent response: {resp_json}")

        self.state.risk_analysis_report = resp_json
        self.state.status = "in_progress"

        if resp_json.get("human_input") is True:
            self.state.message = "Human input required"
        else:
            self.state.message = ""

        return self.state
		
## summarizer_agent.py ##
from .agent_state import AgentState
from prompts.risk_analysis_prompt import risk_analysis_prompt
from llm.gemini_service import call_gemini_llm
from utils.common import extract_json


class RiskAnalysisAgent:
    def __call__(self, state: AgentState):
        self.state = state
        self.user_input = state.input_contract
        return self.run_analyzer()

    def run_analyzer(self) -> AgentState:
        if self.state.feedback:
            self.state.input_contract += f"\nAdditional Context: {self.state.feedback}"

        prompt = risk_analysis_prompt + self.state.input_contract
        resp_text = call_gemini_llm(prompt)
        resp_json = extract_json(resp_text) or {}
        print(f"RiskAnalysisAgent response: {resp_json}")

        self.state.risk_analysis_report = resp_json
        self.state.status = "in_progress"

        if resp_json.get("human_input") is True:
            self.state.message = "Human input required"
        else:
            self.state.message = ""

        return self.state

## validation_agent.py ##
from .agent_state import AgentState
from prompts.validation_prompt import validation_prompt
from llm.gemini_service import call_gemini_llm


class ValidationAgent:
    def __call__(self, state: AgentState):
        self.state = state
        return self.validate_input()

    def validate_input(self) -> AgentState:
        if not self.state.input_contract or len(self.state.input_contract) < 2:
            self.state.errors.append("Input contract is too short or missing.")
            self.state.message = "Input validation failed."
            self.state.status = "failed"
            return self.state

        prompt = validation_prompt + self.state.input_contract

        result = call_gemini_llm(prompt).strip()
        print(f"ValidationAgent response: {result}")

        if "Invalid Input" in result:
            self.state.errors.append("Input contract is not valid contract data.")
            self.state.message = result
            self.state.status = "failed"
        else:
            self.state.message = "ok"
            self.state.status = "in_progress"

        return self.state


# main.py #
import os
from flask import Flask, render_template, request, jsonify
from flask_cors import CORS
from werkzeug.utils import secure_filename
from agents.orchestrator_agent import OrchestratorAgent
from agents.agent_state import AgentState
from utils.docs_reader import process_file


app = Flask(__name__)
CORS(app)


@app.route("/", methods=["GET"])
def index():
    return render_template("index.html")


@app.route("/upload_contract", methods=["POST"])
def upload_contract():
    """
    Endpoint to upload a document and extract text for project_description.
    Expects multipart/form-data with a file field: description_file
    """
    try:
        if "description_file" not in request.files:
            return jsonify({
                "status": "failed",
                "errors": ["'description_file' is required in form-data"],
                "message": "No file part in the request.",
                "project_description": None,
            }), 400

        file = request.files["description_file"]

        if file.filename == "":
            return jsonify({
                "status": "failed",
                "errors": ["Empty filename."],
                "message": "No selected file.",
                "project_description": None,
            }), 400

        text = process_file(file)

        return jsonify({
            "status": "success",
            "errors": [],
            "message": "File processed successfully.",
            "project_description": text,
        }), 200

    except Exception as e:
        return jsonify({
            "status": "failed",
            "errors": ["Exception while processing file."],
            "message": str(e),
            "project_description": None,
        }), 500


@app.route("/analyze_contract_risk", methods=["POST"])
def risk_analysis():
    payload = request.get_json(silent=True) or {}

    project_description = payload.get("project_description", "") or ""
    user_feedback = payload.get("feedback", "") or ""

    # Optional future support for feedback_history list
    feedback_history = payload.get("feedback_history")
    if isinstance(feedback_history, list) and feedback_history:
        if user_feedback:
            feedback_history.append(user_feedback)
        user_feedback = "\n\n".join(str(item) for item in feedback_history if item)

    if not project_description.strip():
        return jsonify({
            "status": "failed",
            "errors": ["'project_description' is required in request body"],
            "message": "Missing project / contract description.",
            "summary": None,
            "risk_analysis_report": None,
        }), 400

    state = AgentState(
        input_contract=project_description,
        feedback=user_feedback or None,
    )

    try:
        agent = OrchestratorAgent(state)
        final_state = agent.run()
    except Exception as e:
        return jsonify({
            "status": "failed",
            "errors": ["Internal orchestration error"],
            "message": f"Orchestrator failed: {str(e)}",
            "summary": None,
            "risk_analysis_report": None,
        }), 500

    response = {
        "status": final_state.status,
        "errors": final_state.errors,
        "message": final_state.message,
        "summary": final_state.summary,
        "risk_analysis_report": final_state.risk_analysis_report,
    }

    return jsonify(response), 200



if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
